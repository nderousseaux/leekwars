include("./weapon.lk");
include("./utils.lk");

class Leek {
	/* Classe représentant un poirreau
	*/

	id;
	weapon;

	constructor(id=getEntity(), weapon=WEAPON_PISTOL) {
		this.id = id;
		this.weapon = new Weapon(weapon);
		setWeapon(weapon);
	}


	/******************************
 	* Accesseurs
	******************************/
	getPosition() { return getCell(this.id) } 
	getX() { return getCellX(this.getPosition())}
	getY() { return getCellY(this.getPosition())}
	getDis(entity) { return getCellDistance(this.getPosition(), entity.getPosition()) }
	getTP() { return getTP(this.id) }
	getMP() { return getMP(this.id) }
	getTotalTP() { return getTotalTP(this.id) }
	getTotalMP() { return getTotalMP(this.id) }
	getCellsReachable() { return getCellsAtDistance(this.getPosition(), this.getMP()) }
	getNearestCover(entity) {
		var res = []
		for(var distance = 0; distance <= 5; distance++) {
			var cells = getCellsAtDistance(me.getPosition(), distance) // On commence par la case la plus proche, puis on augmente la distance.
			for(var i : var cell in cells) {
				if (this.isCover(entity, cell) && !isObstacle(cell)) {
					return cell
				}
			}
		}
		return this.getPosition()
	}

	isInRangeOf(entity) { return entity.canSee(this) && entity.getDis(this) <= entity.weapon.getMaxRange() }
	isCover(entity, cell) {
		isCover = true
		return (!lineOfSight(cell, entity.getPosition()) || getCellDistance(cell, entity.getPosition()) > entity.weapon.getMaxRange())
	}
		
	canSee(entity) { return lineOfSight(this.getPosition(), entity.getPosition()) }
	canMove() { return this.getMP() != 0 }
	canAttack(entity) { return entity.isInRangeOf(this) && this.getTP() >= this.weapon.getCost() }
	canDoSomething(entity) { return this.canMove() || this.canAttack(entity) }


	/******************************
 	* Méthodes
	******************************/
	attack(entity) { useWeapon(entity.id) }
	moveTo(entity, distance) { moveToward(entity.id, distance) }
	moveTo(entity) { moveToward(entity.id) }
	moveAway(entity, distance) { moveAwayFrom(entity.id, distance) }
	moveAway(entity) { moveAwayFrom(entity.id) }
	moveToNearestCover(entity) { moveTowardCell(getNearestCover(entity)) }
}